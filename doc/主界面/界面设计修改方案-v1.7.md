针对你提出的两个问题，以下是精准的修复方案和代码实现：

### 1. 拖拽还原逻辑优化分析
**问题原因：** 之前的实现只是简单地调用了 `showNormal()`，这会让窗口回到最大化之前的坐标。要实现类似原生 Windows 的效果（窗口随鼠标“吸附”还原），我们需要在还原瞬间根据鼠标当前在全屏标题栏上的**相对比例**，计算并重新设置还原后窗口的 `x` 坐标。

### 2. 发送按钮对齐与图标修改
**问题原因：** `Layout.alignment: Qt.AlignBottom` 会导致按钮贴着底部边缘，在胶囊形输入框中视觉上会显得偏下。改为 `Qt.AlignVCenter`（垂直居中）能获得更好的视觉平衡感。

---

### 修改后的参考代码

#### 修复问题 1：标题栏拖拽吸附还原（修改 `titleBar` 内部的 `MouseArea`）

```qml
        MouseArea {
            id: titleBarMouseArea
            anchors.fill: parent
            
            onPressed: {
                if (!window.windowMaximized) {
                    window.startSystemMove()
                }
            }
            
            onPositionChanged: {
                if (pressed && window.windowMaximized) {
                    // 1. 计算鼠标在当前全屏标题栏上的相对横向比例 (0.0 到 1.0)
                    let relativeX = mouse.x / titleBar.width
                    
                    // 2. 还原窗口大小
                    window.showNormal()
                    window.windowMaximized = false
                    
                    // 3. 重新定位窗口：使还原后的窗口标题栏根据比例“吸附”在鼠标位置
                    // 计算公式：屏幕坐标 - (还原后窗口宽度 * 点击时的比例)
                    window.x = mouse.screenX - (window.width * relativeX)
                    window.y = mouse.screenY - mouse.y
                    
                    // 4. 继续接管系统拖动
                    window.startSystemMove()
                }
            }
            
            onDoubleClicked: {
                if (window.windowMaximized) {
                    window.showNormal()
                    window.windowMaximized = false
                } else {
                    window.showMaximized()
                    window.windowMaximized = true
                }
            }
        }
```

#### 修复问题 2：发送按钮对齐与 SVG 图标（修改 `inputContainer` 内部的 `RoundButton`）

```qml
                // 单一发送按钮
                RoundButton {
                    id: sendButton
                    Layout.preferredWidth: 32
                    Layout.preferredHeight: 32
                    // 修改点 1: 改为垂直居中，解决“偏下”问题
                    Layout.alignment: Qt.AlignVCenter 
                    
                    contentItem: Item {
                        // 修改点 2: 替换为 Image 组件并指定图标路径
                        Image {
                            anchors.centerIn: parent
                            width: 16
                            height: 16
                            source: "img/发送.svg"
                            sourceSize: Qt.size(16, 16)
                            // 根据是否有文字改变图标透明度
                            opacity: inputField.text.length > 0 ? 1.0 : 0.4
                            
                            // 简单的颜色过滤（如果需要图标随文字变色，建议 SVG 内部填填充色为透明或在 QML 中处理）
                            // 保持简约，这里直接控制透明度
                        }
                    }
                    
                    background: Rectangle {
                        radius: 16
                        // 逻辑：有文字时背景为白色，无文字时为深色
                        color: inputField.text.length > 0 ? "white" : "#27272a"
                        Behavior on color { ColorAnimation { duration: 200 } }
                    }
                    
                    onClicked: {
                        if (inputField.text.trim() !== "") {
                            messageModel.append({"role": "user", "content": inputField.text})
                            chatController.send_message(inputField.text)
                            inputField.clear()
                            chatList.positionViewAtEnd()
                        }
                    }
                }
```

### 改进要点说明：

1.  **吸附还原算法**：通过 `relativeX` 获取点击位置占总宽度的百分比。这样无论你在标题栏左侧、中间还是右侧拖拽，还原后窗口都会准确地落在鼠标下方，不会产生“瞬移”感。
2.  **垂直居中对齐**：将 `Layout.alignment` 从 `Qt.AlignBottom` 改为 `Qt.AlignVCenter`。在 capsule（胶囊）布局中，这是最符合视觉美学的方案，确保了发送图标与 placeholder 文字在同一水平线上。
3.  **SVG 图标适配**：使用了 `Image` 代替原本的 `Text` 箭头。设置了 `sourceSize` 以确保 SVG 渲染清晰，不模糊。同时加入了基于 `inputField.text.length` 的视觉反馈，未输入文字时图标会变暗。
针对你提出的两个问题，以下是精准的修复方案：

### 1. 标题栏拖拽还原位置修复
**问题分析：** 之前代码中 `mouse.screenX` 和 `mouse.screenY` 可能在窗口状态切换瞬间未正确同步，或者 `window.width` 在 `showNormal()` 调用后没有立即更新。
**解决方案：** 在切换状态前记录全局坐标和比例，并确保在移动窗口坐标时使用正确的屏幕参考系。

### 2. 发送按钮图标切换修复
**问题分析：** 目前只控制了透明度，没有根据输入状态切换图标路径。
**解决方案：** 在 `Image` 的 `source` 属性中使用三元运算符，根据 `inputField.text.length` 动态切换图片路径。

---

### 修改后的代码片段

#### 修复问题 1：标题栏拖拽还原（修改 `titleBar` 内部的 `MouseArea`）

```qml
        MouseArea {
            id: titleBarMouseArea
            anchors.fill: parent
            
            onPressed: {
                if (!window.windowMaximized) {
                    window.startSystemMove()
                }
            }
            
            onPositionChanged: function(mouse) {
                if (pressed && window.windowMaximized) {
                    // 1. 在还原前记录当前鼠标在全屏状态下的比例和全局位置
                    let ratio = mouse.x / titleBar.width
                    let sx = mouse.screenX
                    let sy = mouse.screenY
                    let ly = mouse.y // 记录鼠标在标题栏内的相对高度
                    
                    // 2. 还原窗口
                    window.showNormal()
                    window.windowMaximized = false
                    
                    // 3. 根据比例计算还原后的位置，使鼠标依然位于标题栏相同比例处
                    window.x = sx - (window.width * ratio)
                    window.y = sy - ly
                    
                    // 4. 接管系统拖动
                    window.startSystemMove()
                }
            }
            
            onDoubleClicked: {
                if (window.windowMaximized) {
                    window.showNormal()
                    window.windowMaximized = false
                } else {
                    window.showMaximized()
                    window.windowMaximized = true
                }
            }
        }
```

#### 修复问题 2：发送按钮图标切换（修改 `sendButton` 内部的 `Image`）

```qml
                // 单一发送按钮
                RoundButton {
                    id: sendButton
                    Layout.preferredWidth: 32
                    Layout.preferredHeight: 32
                    Layout.alignment: Qt.AlignVCenter
                    
                    contentItem: Item {
                        Image {
                            anchors.centerIn: parent
                            width: 16
                            height: 16
                            // 修改点：根据输入内容切换图标路径
                            source: inputField.text.length > 0 ? "img/发送.svg" : "img/发送-Empty.svg"
                            sourceSize: Qt.size(16, 16)
                            // 既然切换了图标，透明度可以保持常亮，或者根据喜好微调
                            opacity: 1.0 
                        }
                    }
                    
                    background: Rectangle {
                        radius: 16
                        color: inputField.text.length > 0 ? "white" : "#27272a"
                        Behavior on color { ColorAnimation { duration: 200 } }
                    }
                    
                    onClicked: {
                        if (inputField.text.trim() !== "") {
                            messageModel.append({"role": "user", "content": inputField.text})
                            chatController.send_message(inputField.text)
                            inputField.clear()
                            chatList.positionViewAtEnd()
                        }
                    }
                }
```

### 修改要点说明：

1.  **位置精确计算**：在拖拽还原逻辑中，显式提取了 `mouse.screenX` 和 `mouse.screenY`。通过 `sy - ly`（屏幕纵坐标减去鼠标在标题栏内的局部高度），确保窗口顶部始终紧贴鼠标。
2.  **动态路径绑定**：`source` 属性现在是响应式的。当用户在 `TextArea` 中键入第一个字符时，`inputField.text.length > 0` 变为真，图标会立即从 `发送-Empty.svg` 切换为 `发送.svg`。
3.  **对比度提升**：由于图标进行了切换，解决了“白色背景配白色图标”的问题。请确保 `img/发送.svg` 的设计颜色适合在白色背景上显示（例如黑色或深蓝色）。